#
# Pour cette épreuve, vous devez programmer une IA pour le jeu de tank. Votre IA sera par la suite testé contre les IAs des autres participants.
#
#Dans le jeu de tank, des chars d'assault se livre une guerre sans merci jusqu'à la destruction de tous les adversaires. Pour des fins pratiques, une limite de temps de 3 minutes est imposée à chaque combat.
#
# À chaque tour de boucle
#
# Map  
#
#

# Vous pouvez considérer la possibilité qu'il y aille plusieurs adversaires
#
#


#Disclaimer : Désolé le code est un peu moche. Ça été fait vite avec comme seul objectif que ça fonctionne

import random
import re
from itertools import product
#
reg_move = re.compile('move', re.IGNORECASE)
reg_shoot = re.compile('shoot', re.IGNORECASE)
reg_valid = re.compile('NOPE|MINE|(MOVE|SHOOT)(UP|DOWN|LEFT|RIGHT)')

def handmade1():
    walls = [[0,0,0,0,0,0,0,0,0],
             [0,1,1,1,0,1,0,1,0],
             [0,0,0,0,0,1,0,1,0],
             [0,1,1,1,0,1,0,1,0],
             [0,0,0,0,0,0,0,0,0]]
    initial_pos = [(0,0),(4,9),(0,9),(4,0)]
    
    return Map(walls, initial_pos)        

class Map :
    def __init__(self, walls, initial_pos):
        """ 
        walls is a 2D boolean array where each   
        initial_pos : initial player positions
        
        """
        self.walls = walls
        self.initial_pos = initial_pos
        self.shape = len(self.walls), len(self.walls[0])
                

def empty_map(shape):
    """" shape must be a 2-tuple, max 4 player""""
    walls = [[0 for i in range(shape[0])] for j in range(shape[1])]
    initial_pos = [(0,0),(shape[0],shape[1]), (shape[0],0), (0,shape[1])]
    return Map(walls, initial_pos)
        
def default_map(size=20):
    """ """
    import numpy as np
    
    a = np.zeros((size, size))
    
    a[0], a[size], a[:,0], a[:,size] = np.ones(size)*4
    for i in range(3, size-2 step=2):
        for j in range(3, size-2 step=2):
            a[i,j] = 1

    print(a)
    return a
    print(list(a))
    

class GameManager:
    def __init__(self, players, battlefield=handmade1(), initial_life=50, max_mine=3, random_start=False):
        """"
        """"
                
        self.nb_players = len(players)
        self.decision_functions = players   
        self.map=battlefield
        self.initial_life=initial_life
        if len(battlefield.starting_positions) > nb_players:
            print("Too many players for the map")
        

    def reset(self):

        self.objects_map= [['w' if self.map.walls[j][i] else '' for i in self.map.shape[1]] for j in self.map.shape[0]] # Contains bullet, mines and player.

        #Giving a random starting position to each players
        if random_start = True :
            positions = random.sample(self.map.starting_positions, nb_players)
        else :
            positions = self.map.starting_positions
        
        self.players = []
                    
        for i in range(self.nb_player):                    
            assert self.objects_map[positions[i][0]][positions[i][1]] == '' #If this assertion fail then it means the map has a wall at a starting position
            self.objects_map[positions[i][0]][positions[i][1]] = str(i)
            self.players.append(Player(i, positions[i], self.initial_life))        
        
        self.bullets = []
        self.mines = [[] for i in range(self.nb_players)]
        self.players_alive = set(range(self.nb_players))

        
        
    def limited_view(self, player_id):
        """This function returns a view limited to what a player can see. For partial information variant of the game."""
    
        def check_tile(x0,x1):
            """" At this point""""
            pass
        p0,p1 = self.players[player_id]
        for y0,y1 in (0,1),(0,-1),(1,0),(-1,0):
        #Vue orthogonale
            x0,x1 = position
            while not self.map.walls[][] :
                pass
                
        
        for y0,y1 in product([-1,1],repeat=2):
        #Bresenham line pour les diagonales
        #https://en.wikipedia.org/wiki/Bresenham's_line_algorithm
            x0,x1 = p0+y0, p1+y1         
        pass
    
    def start(self):
        self.reset()        
        
        while True :
            
            #Retrieve an action from each player
            commands = []
            for p in self.players : 
                commands.append(p.action( ))
     
            #Applying actions                
            self.apply_actions(commands)
            
            #See if terminal state
            if self.players_alive <= 1 :
                break
                
        #who is the winner
        if len(players_alive) >= 1:
            print("The winner is "+str(players_alive))
        
        return players_alive

        
        def parse_direction(string):
            """ cast 'UP' to 0,1 'DOWN' to 0,-1 'LEFT' to -1,0 and 'RIGHT' to 1,0 """
            if string == "UP" :
                 return 0,1
            elif string == "DOWN" :
                return 0,-1
            elif string == "LEFT" :
                return -1,0
            elif string == "RIGHT" :
                return 1,0

    def position_on_board(self,x1,x2):
        """certified that a orthogonal position is on the board """ 
        return min(x1,x2,self.map.shape[0]-x1,self.map.shape[1]-x2) <=0 
                 
    def apply_actions(self,actions):
        """
        L'ordre d'application des ordres des tanks est aléatoire. À chaque tour, les paires player_id - action sont mélangées et puis sont exécutées séquentiellement.  
        """
        
        actions = random.shuffle(list(enumerate(actions)))

        while(len(actions) > 0):

            player_id, act = actions.pop()
                      
            if not reg_valid(act) :
                continue
            
            x1,x2 = self.positions[player_id]
            
            #Applying drop mine
            if act[:4] == "MINE":
                
                if len(self.mines[player_id]) >= self.max_mine:
                    """If a tank already has place the maximum allowed number of mines and tries to place another then we remove the oldest mine"""
                    self.remove_object(self.mines[player_id].pop(0))
                    
                m = Item('m',(x1,x2))
                self.object_map[x1][x2] += 'm'
                self.mines[player_id].add(m)
                
            #Applying shoots
            elif act[:5] == "SHOOT"

                d1,d2 = parse_direction(act[6:])
                y1, y2 = x1+d1,x2+d2
                if position_board(y1,y2) and not self.map.walls[y1][y2]:
                    if self.object_maps :

                    x = Item('*', (y1,y2))
                    x.direction = (d1,d2)
                    self.bullets.append(x)
                    
            #Applying move
            elif act[:4] == "MOVE":
                d1,d2 = parse_direction(act[5:])
                y1,y2 = x1+d1,x2+d2
                if self.position_on_board(y1,y2) and not self.map.walls[y1][y2]: 
                    if self.object_maps
                    self.move
                    
        #making those bullets move
        self.iterate_bullets()            
            
    def iterate_bullets(self):
        """make all the bullets move 1 tile in their given direction. Resolve colision with wall, tanks and mines. Collision with other bullets are ignored."""
        i=0
        while i < len(self.bullets):
            
            b = self.bullets[i]:
            for z in range(2):
                y1,y2 = b.direction[i]+b.pos[i] for i in 0,1
                if self.position_on_board(y1,y2) and not self.map.walls[y1][y2]:
                    
                    #Checking if collision with mines or player               
                    if self.objects_maps[y1][y2] == '' or self.objects_maps[y1][y2] == '*':
                        self.move_object(b,b.direction[0], b.direction[1])
                        
                    else :
                        if self.objects_maps[y1][y2] == 'm':
                            
                                    
                    b.pos = b.pos[0] + b.direction[0], b.pos[1] + b.direction[1] 
                i += 1
            else :
                self.bullets.pop(i)    
    
    
    def print_board(self):
        board = ''
        for i in self.map.shape[0]:
            for j in self.map.shape[1]:
                if self.map.walls[i][j] :
                    board += '#'
                elif True: #fix this shit
                    board += '*' #bullet
                elif True:
#   player                    board +=                
                else :
                    board += '.'
                
            board += '\n'
    
    def move_object(self, obj, d0, d1):
        """ obj :
        d0,d1 : the deltas of the position"""
        self.object_map[obj.pos[0]][obj.pos[1]].remove(obj.label)        
        obj.pos = obj.pos[0]+d0,obj.pos[1]+d1
        self.object_map[obj.pos[0]][obj.pos[1]]
    
    def remove_object(self, obj):
        """  """
        self.object_map[obj.pos[0]][obj.pos[1]].remove(obj.label)
    
class Item:
#      A general item template for bullet and mines. Bullets instances will have an attribute direction and mines will have an attribute player.
#      
    def __init__(self,label, position): 
        self.label=label
        self.pos=position
    
class Tank:
    def __init__(self,player_id, position, initial_life):
        self.pos=position
        self.label = player_id
        self.life = initial_life
        self.last_move = None
        
def action(last_action, config, positions):
        # Actions possibles : ["MOVE X", "SHOOT X", "MINE","NOPE"]
        # où X dans l'action MOVE et SHOOT représente une direction. 
        # Directions possibles : ["UP","DOWN","LEFT", "RIGHT"]
        a = random.choice(["MOVE", "SHOOT", "MINE", "NOPE"])
        
        if a == "MOVE" || a == "SHOOT":
            a += " " +random.choice(["UP","DOWN","LEFT", "RIGHT"])
        return a    
    
    
    
    
    
    
    
